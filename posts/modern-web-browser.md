---
title: 최신 웹 브라우저 살펴보기
date: '2023-03-13'
description: 최신 웹 브라우저는 우리가 작성한 코드를 어떻게 반영할까
tags: ['브라우저', '최적화', '크롬', '렌더링', '번역']
thumbnail: 'thumbnail.jpg'
---

> 해당 포스팅은 원문인 [_Inside look at modern web browser_](https://developer.chrome.com/blog/inside-browser-part1/)를 필자의 입맛에 맞게 번역 및 정리한 글입니다. 자세한 내용은 원문을 참고해주세요.

4부로 구성된 해당 시리즈에서 높은 수준의 아키텍처부터 렌더링 파이프라인의 세부 내용에 이르기까지 크롬 브라우저 내부를 살펴보도록 하겠습니다.

# 핵심 컴퓨팅 용어와 크롬의 다중 프로세스 아키텍처

---

이 시리즈 1부에서는 핵심 컴퓨팅 용어와 크롬의 다중 프로세스 아키텍처에 대해 살펴보겠습니다.

## 컴퓨터의 핵심은 CPU와 GPU

---

브라우저 실행을 이해하기 위해 몇 가지 부품들과 그 기능을 이해해야 합니다. 해당 글에선 주요 부품인 **GPU와 CPU**에 대해서 알아보도록 하겠습니다.

### CPU

---

중앙 처리 장치인 **CPU**는 **컴퓨터의 두뇌**라고 할 수 있으며, 다음의 특징을 갖습니다.

- 다양한 작업을 하나씩 처리할 수 있습니다.
- 과거에는 대부분의 CPU가 단일 칩이었습니다.
- 최신 하드웨어에서는 동일한 칩에 있는 다른 CPU인 **코어**를 둘 이상씩 사용하여 휴대폰 및 노트북에 더 좋은 컴퓨팅 성능을 제공합니다.

### GPU

---

그래픽 처리 장치인 **GPU**는 컴퓨터의 또 다른 부분이며 다음의 특징을 갖습니다.

- CPU와 달리 **간단한 작업 처리에 능숙**하지만, 동시에 **여러 코어에 걸쳐 있습니다.**
- 이름과 같이 **그래픽 처리**를 위해 개발되었으며, 이것이 GPU 사용 혹은 GPU 지원이 빠른 렌더링 및 원활한 인터랙션과 과련된 이유입니다.
- 최근 몇 년 동안 GPU 가속 컴퓨팅을 통해, 많은 컴퓨팅이 **GPU 단독**으로 가능해지고 있습니다.

컴퓨터나 휴대폰에서 응용 프로그램을 시작하면 위 두 가지 부품이 응용 프로그램을 구동합니다. 일반적으로 응용 프로그램은 **운영 체제에서 제공하는 메커니즘**을 사용하여 CPU 및 GPU에서 실행됩니다.

## 프로세스 및 스레드에서 프로그램 실행

---

브라우저 아키텍처를 이해하기 전 알아야 할 또 다른 개념으로 **프로세스 및 스레드**가 있습니다. 간단히 말하자면, 프로세스는 **응용 프로그램 내 실행 프로그램**이며, 스레드는 **프로세스 내부에서 프로그램 일부를 실행하는 것**입니다. 응용 프로그램 실행 과정을 통해 이를 더 자세히 알아보도록 합시다.

우선 응용 프로그램을 실행하면 **프로세스가 생성**됩니다. 이때 스레드를 생성할 수 있지만, 선택 사항입니다. 운영 체제는 작업할 **메모리의 판을 프로세스에 제공**하고 **모든 응용 프로그램 상태는 해당 메모리에 저장**됩니다. 응용 프로그램을 닫으면 **프로세스도 사라지고**, 운영 체제에서 **메모리를 확보**합니다.

> 여기서 **판**(원문 내 "slab")은 사전적으로 건축에서 판 형상의 구조물을 의미하는데, 원문에서는 **애플리케이션 메모리를 저장하는 영역**을 정의하기 위해 비유적으로 활용한 표현이라고 생각됩니다.

프로세스는 다른 작업을 실행하기 위해 **다른 프로세스를 가동하도록 운영 체제에 요청**할 수 있습니다. 이렇게 되면 **다른 메모리의 일정 부분이 새 프로세스에 할당**됩니다. 두 프로세스가 통신해야 하는 경우 **IPC**(Inter Process Communication)를 활용하여 통신할 수 있습니다. 많은 응용 프로그램은 작업자 프로세스가 응답하지 않는 경우, 응용 프로그램의 다른 부분을 실행하는 다른 프로세스를 중지하지 않고 다시 시작할 수 있도록 이러한 방식으로 설계되었습니다.

## 브라우저 아키텍쳐

---

그렇다면 프로세스와 스레드를 활용하여 웹 브라우저를 구축하는 방법을 알아봅시다. 여러 스레드가 있는 하나의 프로세스이거나 IPC를 통해 통신하는 몇 개의 스레드가 있는 여러 프로세스일 수 있습니다. 이러한 아키텍쳐들은 구현 세부 사항이며 표준 사양이란 없습니다.

> 해당 시리즈에선 최신 크롬 아키텍처를 활용하여 설명합니다.

최상단엔 응용 프로그램 내 다른 부분들을 관리하는 프로세스와 협력하는 **브라우저 프로세스**가 있습니다. **렌더러 프로세스**의 경우 여러 프로세스가 생성되어 각 탭에 할당됩니다.

> 최근까지 크롬은 가능한 경우 각 탭에 프로세스를 제공했으나, 이제 `iframe` 을 포함하여 **각 사이트에 자체 프로세스를 제공**하려는 시도를 합니다. ([사이트 격리](https://developer.chrome.com/blog/inside-browser-part1/#site-isolation) 참조)

## 프로세스의 제어 대상

---

크롬 내 프로세스들과 제어 대상은 다음과 같습니다.

- **브라우저 프로세스**는 주소 표시줄, 북마크, 뒤로 및 앞으로 버튼을 포함하여 **애플리케이션의 "크롬" 부분을 제어**합니다. 또한, 네트워크 요청 및 파일 액세스와 같은 웹 브라우저의 보이지 않는 권한 부분을 처리합니다.
- **렌더러 프로세스**는 웹사이트가 표시되는 **탭 내부의 모든 것**을 제어합니다.
- **플러그인 프로세스**는 예를 들어, 플래시와 같이 **웹 사이트에서 사용하는 모든 플러그인**을 제어합니다.
- **GPU 프로세스**는 다른 프로세스와 별도로 **GPU 작업을 처리**합니다. GPU가 여러 앱의 요청을 처리하고 동일한 표면에 그리기 때문에 다른 프로세스로 분리됩니다.

이외에도 확장 프로세스 및 유틸리티 프로세스와 같은 더 많은 프로세스들이 있습니다.

> 크롬 내에서 실행 중인 프로세스 수를 확인하려면 오른쪽 상단 모서리에 있는 **케밥 아이콘**(⋮)을 클릭하고 추가 도구를 클릭한 후, 작업 관리자를 선택하면 현재 실행 중인 프로세스 목록과 사용 중인 CPU/메모리 양이 표시된 창이 열립니다.

## 크롬 다중 프로세스 아키텍처의 이점

---

앞에서 크롬이 **다중 렌더러 프로세스**를 사용한다고 언급했었는데, 가장 간단한 경우는 **각 탭에 자체 렌더러 프로세스가 있다**고 생각할 수 있습니다. 이렇게 하면 **하나의 탭이 응답하지 않아도 나머지 탭을 활성 상태로 유지**하며 진행할 수 있습니다.

각 프로세스는 고유한 메모리 공간을 갖지만 **공통 인프라(예를 들어, 크롬의 자바스크립트 엔진인 V8)의 복사본을 포함하는 경우**가 많습니다. 이는 동일 프로세스 내부의 스레드인 경우 공유할 수 없기 때문에, **더 많은 메모리 사용량을 초래**합니다. 메모리 절약을 위해 크롬은 **가동 가능한 프로세스 수를 제한**합니다. 한도는 기기 메모리 및 CPU 성능에 따라 다르겠지만, 크롬이 **한도에 도달하면 한 프로세스에서 같은 사이트의 여러 탭을 실행**합니다.

## 더 많은 메모리 절약을 위한 크롬의 서비스

---

동일 접근 방식이 브라우저 프로세스에 적용됩니다. 크롬은 **브라우저 프로그램의 각 부분을 서비스로 실행**하여 여러 프로세스로 쉽게 분할하거나 하나로 통합할 수 있도록 아키텍처를 변경하고 있습니다.

일반적으로 크롬이 좋은 성능의 하드웨어에서 실행될 때에는 각 서비스를 다른 프로세스로 분할하여 높은 안정성을 제공하지만, 리소스가 제한된 장치의 경우 크롬은 서비스를 **하나의 프로세스(단일 브라우저 프로세스 등)로 통합**하여 메모리 공간을 절약합니다. 메모리 절약을 위한 프로세스 통합과 같은 방식이 이전에 안드로이드와 같은 플랫폼에서 사용되었습니다.

## 프레임 별 렌더러 프로세스, 사이트 격리

---

[**사이트 격리(Site Isolation)**](https://developer.chrome.com/blog/site-isolation/)는 **사이트 내 각 `iframe` 에 대해 별도의 렌더러 프로세스를 실행**하는 크롬의 최신 기능입니다. 우리는 서로 다른 사이트 간 메모리 공간을 공유하는 단일 렌더러 프로세스 내 사이트 간 `iframe` 을 실행할 수 있는 탭 모델당 하나의 렌더러 프로세스에 대해 이야기한 바가 있습니다. 동일한 렌더러 프로세스에서 두 가지 사이트를 실행하는 것이 좋아보일 수 있습니다. [**동일 출처 보안 방식**](https://developer.mozilla.org/ko/docs/Web/Security/Same-origin_policy)은 웹의 핵심 보안 모델이며, 이는 **한 사이트가 동의 없이 다른 사이트의 데이터에 액세스할 수 없도록 합니다.** 이 정책을 우회하는 것이 주요 공격 방식이며, 프로세스 격리는 사이트를 분리하는 가장 효과적인 방법입니다. [Meltdown과 Spectre](https://developer.chrome.com/blog/meltdown-spectre/)로 인해 프로세스를 활용하여 사이트를 분리해야 한다는 것이 더욱 확실해졌기에, 크롬 67부터 기본적으로 데스크톱에서 사이트 격리가 활성화되어 있으므로 탭의 각 교차 사이트 `iframe` 은 별도의 렌더러 프로세스를 가져옵니다.

사이트 격리는 다른 렌더러 프로세스를 할당하는 것처럼 단순하지 않습니다. **`iframe` 이 서로 커뮤니케이션 하는 방식을 근본적으로 변경**합니다. 다른 프로세스에서 실행되는 `iframe` 이 있는 페이지에서 개발자 도구를 여는 것은 개발자 도구가 매끄럽게 보이도록 백그라운드 작업을 구현해야 한다는 것을 의미합니다. 페이지에서 단어를 찾기 위해 Ctrl+F를 실행하는 것조차 다른 렌더러 프로세스에서 검색하는 것을 의미합니다. 브라우저 엔지니어가 사이트 격리 릴리스를 주요 이정표로 언급하는 이유를 알 수 있습니다!

# 네비게이션에서 일어나는 일

---

해당 파트에선 **웹 사이트를 표시하기 위해 각 프로세스와 스레드가 통신하는 방법**에 대해 자세히 알아봅니다. 웹 브라우징의 간단한 사례로, 브라우저에 URL을 입력하여 브라우저가 인터넷에서 데이터를 가져와 페이지를 표시하는 경우 살펴보겠습니다. 이 중 사용자가 사이트를 요청하고 **브라우저가 페이지를 렌더링할 준비를 하는 부분**(네비게이션이라고도 함)에 중점을 둡니다.

## 브라우저 프로세스로 시작합니다

---

1부에서 다룬 것처럼 탭 외부의 모든 것은 **브라우저 프로세스**에서 처리됩니다. 브라우저 프로세스에는 다음과 같은 스레드들이 있습니다.

- 브라우저 버튼 및 입력 필드 등을 그리는 **UI 스레드**
- 인터넷에서 데이터를 수신하기 위해 네트워크 스택을 처리하는 **네트워크 스레드**
- 파일에 대한 액세스를 제어하는 **스토리지 스레드** 등

## 간단한 탐색

---

### 1단계, 입력 처리

---

사용자가 주소 표시줄에 입력을 하면 UI 스레드는 우선적으로 **입력 내용이 검색어인지 URL인지를 판단**합니다. 이에 따라 사용자를 검색 엔진으로 보낼지, 요청한 사이트로 보낼지 여부를 구문 분석을 통해 결정해야 합니다.

### 2단계, 네비게이션 시작

---

사용자가 엔터키를 누르면 UI 스레드가 **네트워크 호출을 시작**하여 사이트 콘텐츠를 가져옵니다. 로딩 스피너가 탭 모서리에 표시되며, 네트워크 스레드는 **DNS 조회 및 요청에 대한 TLS 연결 설정**과 같은 적절한 프로토콜을 거칩니다.

> **DNS(Domain Name System)**: 사람이 읽을 수 있는 도메인 이름을 기계가 읽는 IP 주소로 변환하는 것

> **TLS(Transport Layer Security)**: 인터넷 커뮤니케이션을 위한 개인 정보와 데이터 무결성을 제공하는 보안 프로토콜

이 시점에서 네트워크 스레드는 HTTP 301과 같은 **서버 리디렉션 헤더**를 수신할 수 있습니다. 이 경우 네트워크 스레드는 **서버가 리디렉션을 요청하는 UI 스레드와 통신**합니다. 그런 다음 다른 URL 요청이 시작됩니다.

### 3단계, 응답 읽기

---

응답 본문(페이로드)이 들어오기 시작하면 네트워크 스레드는 필요한 경우 **스트림의 처음 몇 바이트를 확인**합니다. 응답의 Content-Type 헤더는 데이터 유형을 말해야 하지만 누락되거나 잘못되었을 수 있으므로 여기서 [MIME 타입 스니핑](https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/MIME_types)이 수행됩니다.

> **MIME 타입**: 클라이언트에게 전송된 문서의 다양성을 알려주기 위한 메커니즘.

> **MIME 스니핑**: MIME 타입이 없을 때, 혹은 클라이언트가 타입이 잘못 설정되었다고 판단한 어떤 다른 경우 **리소스를 훑어 정확한 MIME 타입을 추측해내는 것**.

응답이 **HTML 파일**인 경우 다음 단계는 **렌더러 프로세스에 데이터를 전달**하는 것이지만 **`zip` 파일이나 다른 파일**인 경우 다운로드 요청이므로 데이터를 **다운로드 관리자**에게 보내야합니다. [세이프 브라우징](https://safebrowsing.google.com/) 확인이 이루지기도 합니다. 도메인과 응답 데이터가 악성 사이트와 일치하는 것으로 간주되면 네트워크 스레드가 이에 대한 경고를 표시하도록 전달합니다. 또한 민감한 사이트 간 데이터가 렌더러 프로세스에 전달되지 않도록 하기 위해 [CORB(Cross Origin Read Blocking)](https://developer.chrome.com/blog/inside-browser-part2/) 검사가 수행됩니다.

### 4단계, 렌더러 프로세스 찾기

---

모든 검사가 완료되어 네트워크 스레더가 요청된 사이트로 브라우저 이동이 가능하다고 확신하면 네트워크 스레드는 **데이터가 준비되었음을 UI 스레드에게 알립니다.** 그러면 UI 스레드는 웹 페이지 렌더링을 수행할 **렌더러 프로세스**를 찾습니다.

하지만 네트워크 요청에 대한 응답을 받는데 수백 밀리초가 걸릴 수 있기에, 프로세스 속도를 높이기 위한 다음의 **최적화**가 진행됩니다. UI 스레드가 2단계에서 네트워크 스레드에 URL 요청을 보낼 때, 탐색 중인 사이트를 이미 알고 있습니다. 그래서 UI 스레드는 **네트워크 요청과 병렬로 렌더러 프로세스를 사전에 찾거나 시작하려고 시도**합니다. 이렇게 모든 것이 예상대로 진행되면 렌더러 프로세스는 네트워크 스레드가 데이터를 수신했을 때, 이미 대기하고 있는 상태일 것입니다. 탐색이 교차 사이트로 리디렉션 되는 경우 해당 대기 프로세스가 사용되지 않을 수 있으며, 이 경우 다른 프로세스가 필요할 수 있습니다.

### 5단계, 탐색 커밋

---

이제 데이터와 렌더러 프로세스가 준비되었기에 **탐색을 커밋**하기 위해 **브라우저 프로세스에서 렌더러 프로세스로 IPC가 전송**됩니다. 또한, 렌더러 프로세스가 HTML 데이터를 계속 수신할 수 있도록 **데이터 스트림을 전달**합니다. 브라우저 프로세스가 렌더러 프로세스에서 커밋이 발생했다는 확인을 받으면 **탐색이 완료**되고 **문서 로드 단계가 시작**됩니다.

이떄 **주소 표시줄이 업데이트**되고 **보안 표시 및 사이트 설정 UI에 새 페이지의 사이트 정보가 반영**됩니다. **탭의 세션 기록이 업데이트**되어 뒤로/앞으로 버튼이 방금 탐색한 사이트를 통해 이동합니다. 탭이나 창을 닫을 때, 탭/세션 복원을 용이하게 하기 위해 **세션 기록이 디스크에 저장**됩니다.

### 추가 단계, 초기 로드 완료

---

탐색이 커밋되면 렌더러 프로세스는 리소스 로드를 계속하고 페이지를 렌더링합니다. 그리고 렌더링을 "완료"(페이지의 모든 프레임에서 모든 `onload` 이벤트가 실행이 완료된 후)하면 **IPC를 다시 브라우저 프로세스로 보냅니다.** 이 시점에서 **UI 스레드는 탭에서 로딩 스피너를 중지**합니다.

클라이언트 측 자바스크립트는 이 시점 이후에도 추가 리소스를 불러오고 새 뷰를 렌더링할 수 있기에 "완료"라고 말합니다.

## 다른 사이트로 이동

---

간단한 네비게이션이 완성되었습니다. 하지만 사용자가 다시 주소 표시줄에 다른 URL을 입력하면 어떻게 될까요? 브라우저 프로세스는 동일한 단계를 거쳐 다른 사이트로 이동합니다. 그러나 그 전에 현재 렌더링 된 사이트에서 **`beforeunload` 이벤트에 관심이 있는 지**를 확인해야 합니다.

`beforeunload` 는 다른 패이지로 이동하려고 하거나 탭을 닫으려고 할 때, **"이 사이트를 떠나시겠습니까?"** 라는 경고를 줄 수 있습니다. 자바스크립트 코드를 포함하여 탭 내부의 모든 것은 렌더러 프로세스에 의해 처리되므로 브라우저 프로세스는 **새 탐색 요청이 들어올 때 현재 렌더러 프로세스를 확인**해야 합니다.

> **무조건 `beforeunload` 핸들러를 추가하지 마세요**
>
> 이 경우 네비게이션을 시작하기 전에 핸들러를 실행해야 하므로 **더 많은 대기 시간이 발생**합니다. 이 이벤트 핸들러는 사용자가 페이지에 입력한 데이터가 손실될 수 있다는 경고를 받아야 하는 경우 같이 필요한 경우에만 추가해야 합니다.

**탐색이 렌더러 프로세스에서 시작된 경우**(예를 들어, 사용자가 **링크를 클릭**했거나 클라이언트 측의 자바스크립트가 **`window.location = "https://newsite.com"` 를 실행한 경우**), 렌더러 프로세스는 **`beforeunload` 핸들러를 우선적으로 확인**합니다. 그런 다음 브라우저 프로세스 시작 탐색과 동일한 프로세스를 거칩니다. 유일한 차이점은 탐색 요청이 **렌더러 프로세스에서 브라우저 프로세스로 시작된다는 것**입니다.

현재 렌더링된 사이트가 아닌 다른 사이트로 새 탐색이 수행되면 현재 렌더링 프로세스가 `unload` 와 같은 이벤트를 처리하는 동안 **새 탐색을 처리하기 위해 별도의 렌더링 프로세스를 호출**합니다. 자세한 내용은 [페이지 수명 주기 상태 개요](https://developers.google.com/web/updates/2018/07/page-lifecycle-api#overview_of_page_lifecycle_states_and_events) 및 [페이지 수명 주기 API](https://developers.google.com/web/updates/2018/07/page-lifecycle-api)로 이벤트에 연결하는 방법을 통해 알아보세요.

## 서비스 워커의 경우

---

해당 탐색 프로세스에 대한 최근 변경 사항 중 하나는 [**서비스 워커**](https://developers.google.com/web/fundamentals/primers/service-workers/)의 도입입니다. 서비스 워커는 **애플리케이션 코드에 네트워크 프록시를 작성하는 방법**입니다. 웹 개발자가 로컬로 캐시할 항목과 네트워크에서 새 데이터를 가져올 시기를 더 잘 제어할 수 있도록 만들어줍니다. 서비스 워커가 캐시에서 페이지를 로드하도록 설정되어 있으면 네트워크에서 데이터를 요청할 필요가 없습니다.

기억해야 할 중요한 부분은 **서비스 워커가 렌더러 프로세스에서 실행되는 자바스크립트 코드라는 점**입니다. 그러나 탐색 요청이 들어올 때 브라우저 프로세스는 사이트에 서비스 작업자가 있는 지 어떻게 알 수 있을까요?

서비스 워커가 등록되면 **서비스 워커의 스코프가 참조로 유지**됩니다.

> 스코프에 대한 자세한 내용은 [The Service Worker Lifecycle](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle) 참조

탐색이 발생하면 네트워크 스레드는 **등록된 서비스 워커 스코프에 대해 도메인을 확인**하고 서비스 워커가 해당 URL에 등록된 경우 UI 스레드는 서비스 워커 코드를 실행하기 위해 렌더러 프로세스를 찾습니다. 그러면 서비스 워커는 캐시에서 데이터를 로드하여 네트워크에서 데이터를 요청할 필요가 없도록 하거나 네트워크에서 새 리소스를 요청할 수 있습니다.

## 네비게이션 프리로드

---

결국 서비스 워커가 네트워크에서 데이터를 요청하기로 결정했다면, 브라우저 프로세스와 렌더러 프로세스 간의 왕복으로 지연이 발생할 수 있음을 알 수 있습니다. [네비게이션 프리로드](https://developers.google.com/web/updates/2017/02/navigation-preload)는 이런 상황에서 **서비스 워커 시작과 함께 병렬로 리소스를 로드**하여 해당 프로세스의 속도를 높이는 메커니즘입니다. **헤더로 이러한 요청을 표시**하여 서버가 이러한 요청에 대해 다른 콘텐츠를 보낼지 결정할 수 있도록 합니다.
